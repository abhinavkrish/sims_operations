#!/usr/bin/env python

import os
import os.path
import sys
import re
import MySQLdb


# Globals.
sessionID = 1       # session ID to consider for all DB queries

def colify(stuff):
    """
    Given stuff, a list of strings, parse each string into columns,
    find the max width of each column, then return a list of
    formatted strings where the columns line up.  Only support:

    * left-justification
    * space-delimited
    * all lines must have same # tokens
    """
    colwidths = {}
    result = []
    for line in stuff:                  # each line
        toks = line.split()             # split into tokens
        for col in range(len(toks)):    # for each column (token)
            colwidths[col] = max(colwidths.get(col, 0), len(toks[col]))

    # Build format string.
    fmts = []
    keys = colwidths.keys()
    keys.sort()
    for c in keys:
        fmts.append("%%-%ds" % colwidths[c])
    fmt = " ".join(fmts)

    # Re-scan, formatting into max widths
    for line in stuff:
        toks = line.split()
        result.append(fmt % tuple(toks))

    return result


def sql1(sql):
    """
    Return single value from SQL query.
    """

    try:
        connection = openConnection()
        cursor = connection.cursor()
        n = cursor.execute(sql)
        res = cursor.fetchall()
        return res[0][0]        # 0th value from 0th row
    except Exception, e:
        sys.stdout.write("SQL failed: %s\n" % str(e))
        raise e


def nightly():

    # Get a connection to the DB
    connection = openConnection()
    cursor = connection.cursor()


    # Get sim start date.
    start_mjd = sql1("select simEpoch + simStartDay from LsstConf where sessionID=%d" % sessionID)
#    runtime_days = sql1("select nRun * 365 from LsstConf where sessionID=%d" % sessionID)
    runtime_days = sql1("select max(date) / 86400 from TimeHistory where sessionID=%d" % sessionID)
    survey_time_sec = sql1("select sum(o.expTime+o.slewTime) from ObsHistory o where sessionID=%d" % sessionID)
    idle_time_sec = sql1("select sum(n.expEndTime-n.expStartTime) from NOBHist n where sessionID=%d" % sessionID) or 0;

    if start_mjd is None or runtime_days is None or idle_time_sec is None:
        sys.stdout.write("Could not retrieve runtime parameters.  Session is incomplete.\n");
        sys.exit(1)
    if survey_time_sec is None:
        sys.stdout.write("Could not retrieve survey runtime.  Session is incomplete.\n");
        sys.exit(1)
    dark_time_sec = survey_time_sec + idle_time_sec


    # Get different proposals.
    sql = '''\
select propID, propName, propConf from Proposal
'''
    prop = {}
    n = cursor.execute(sql)
    rows = cursor.fetchall()
    for row in rows:
        propname = re.sub('PS_', '', os.path.splitext(os.path.split(row[2])[1])[0]).upper()
        prop[row[0]] = {
            'propName': row[1],
            'propConf': propname,
        }

    # Get data for proposals.
    nightly_data = {}
    sql = '''\
select o.propID, floor(o.expDate / 86400), count(o.filter), o.filter from ObsHistory o group by o.propID, floor(o.expDate / 86400), o.filter
'''
    min_nn = None
    max_nn = None
    n = cursor.execute(sql)
    rows = cursor.fetchall()
    for row in rows:
        propID, nn, numobs, filter = row[0], row[1], row[2], row[3]
        propname = prop[propID]['propConf']
        key = "%s-%s" % (propname, filter)
        if key not in nightly_data:
            nightly_data[key] = { nn: numobs }
        else:
            nightly_data[key].update({ nn: numobs })
        if min_nn is None or nn < min_nn:
            min_nn = nn
        if max_nn is None or nn > max_nn:
            max_nn = nn


    # Headers.
    print """\
Simulation Start Date: MJD %.5f
Simulation End Date: MJD %.5f
Simulation Run Time: %.5f days
Idle Time: %.2f sec
Dark Time: %.2f sec
""" % (start_mjd, start_mjd + runtime_days, runtime_days, idle_time_sec, dark_time_sec)

    do_colify = 1           # format tabular data into columns
    output = []             # output table
    cols = nightly_data.keys()
    cols.sort()
#    output.append(" ".join(['Night'] + [prop[c]['propName'] for c in cols]))
    output.append(" ".join(['Number'] + [c for c in cols]))

    # Nightly data.
##    print [len(nightly_data[c]) for c in cols]

    for n in range(0, max_nn + 1):
        output.append(" ".join(["%d" % (n + 1)] + [ ("%d" % nightly_data[k].get(n, 0)) for k in cols]))

    # Write output
    if do_colify:
        for line in colify(output):
            print line
    else:
        for line in output:
            print line

if __name__ == "__main__":
    if len(sys.argv) > 1:
        os.environ['DBDB'] = sys.argv[1]      # user specified DBDB as arg
    from LSSTDBInit import *
    nightly()
