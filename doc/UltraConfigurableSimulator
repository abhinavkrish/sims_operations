doc/UltraConfigurableSimulator

In August 2004, the just-constituted simulation team, Francesco Pierfederici, 
Francisco Delgado, and Frances (Robyn) Allsman, were starting the design of
an extremely versatile simulator. Unfortunately,  within a few weeks, the
team's goal and deadline was changed to require the production of a fully
functional simulator within 2 months.  The initial design was immediately 
simplified in order to meet that deadline.

This document summarizes the user interface for the ultra-configurable 
simulator which would enable users to fully configure science programs from 
atomic rule elements.

In essence, the simulator would provide a smorgasbord of atomic contraints 
and bonuses from which the user would select and further quantify into a
detailed characterization of the Science Program's target selection rules.

The constraints and bonuses would be chained together by a simple 
grammar using 'AND', 'OR' and parentheses to define the relationships
between the constraints and, similarly, the bonuses.

The actual execution of these atomic constraints and bonuses would use
the python facility to execute in-line python code.

In hindsight, our initial suggestions for atomic snippets were too
few and too limited.  As our experience with the Science requirements 
of the simulator has grown over the last  year, our understanding of 
a better set of atomic constraints has evolved. And, in fact, the current
simulator has moved towards a more consistent use of constraints across
all proposal types.  Only the cadence and ranking are still tied to
a specific proposal type and even those boundaries based on proposal type
are blurring.  

The constraints fall into 3 independant groups:
1) Field (or target) selection
2) Cadence Specification
3) Science characteristics selection

The bonuses relate entirely to ranking the potential targets:
1) Intra-proposal Ranking between peers in a single proposal;
2) Inter-proposal Ranking between the various proposals.


The document:  doc/CurrentCapabilities, enumerates the set of constraints 
and bonuses already being applied for target selection; they are grouped
as mentioned above.  They are not implemented using the originally envisaged 
python in-line code executions but are hard coded in the definition of 
each specific proposal type.    
